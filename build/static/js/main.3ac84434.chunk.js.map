{"version":3,"sources":["utils/helpers.js","components/field.js","utils/swipeDetection.js","components/App.js","serviceWorker.js","index.js"],"names":["rotate45","matrix","reversed","i","row","j","push","match","arr","a","b","x","y","Field","props","gameOver","isWin","bestFromStorage","JSON","parse","localStorage","getItem","cells","latest","latestCoordinates","score","allCells","map","item","react_default","createElement","className","key","Fragment","initNewField","swipedetect","el","callback","swipedir","startX","startY","distX","distY","startTime","touchsurface","handleswipe","addEventListener","e","touchobj","changedTouches","pageX","pageY","Date","getTime","preventDefault","Math","abs","App","state","size","handleSwipe","field","document","querySelector","_this","swipeDetect","alert","newState","this","moveUp","setState","moveRight","moveDown","moveLeft","checkStep","moved","restart","makeRandomCell","cells1","handleKeyDown","bind","finishScore","newData","slice","indexOf","length","shift","stringify","addToStorage","isGameOver","setBestScore","data","rt","availableCells","randomNumber","floor","random","avCells","areMatches","event","keyCode","result","ifGamesOver","arr2","rotated","components_field","onClick","Component","Boolean","window","location","hostname","ReactDOM","render","components_App","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.3ac84434.chunk.js","sourcesContent":["export const addToStorage = (item, key) => {\n  const data = localStorage[key] ? JSON.parse(localStorage[key]) : [];\n  let newData = data.slice();\n  if (item) {\n    if (newData.indexOf(item) === -1) {\n      newData.push(item);\n    }\n    if (newData.length === 100) {\n      newData.shift();\n    }\n    localStorage[key] = JSON.stringify(newData);\n  }\n};\nexport const reverseY = matrix => {\n  let reversed = [];\n  for (let i = 0; i < 4; i++) {\n    let row = [];\n    for (let j = 0; j < 4; j++) {\n      row.push(matrix[3 - i][j]);\n    }\n    reversed.push(row);\n  }\n  return reversed;\n};\nexport const rotate45 = matrix => {\n  let reversed = [];\n  for (let i = 0; i < 4; i++) {\n    let row = [];\n    for (let j = 0; j < 4; j++) {\n      row.push(matrix[3 - j][i]);\n    }\n    reversed.push(row);\n  }\n  return reversed;\n};\nexport const match = (arr, a, b, x, y) => {\n  return arr[a] && arr[a][b] && arr[a][b] === arr[x][y];\n};\n","import React from \"react\";\n\nconst Field = props => {\n  let gameOver = props.props.gameOver;\n  let isWin = false;\n  let bestFromStorage = JSON.parse(localStorage.getItem(\"score\"));\n  const initNewField = () => {\n    let cells = props.props.cells;\n    let latest = props.props.latestCoordinates;\n    let score = props.props.score;\n    let allCells = cells.map((item, x) => {\n      return item.map((i, y) => {\n        if (i === 2048) {\n          isWin = true;\n        }\n        return (\n          <div className=\"cell-wrapper\" key={'wrap-'+x+y+i}>\n            <div\n              className={\n                \"cell \" +\n                (latest && x === latest.i && y === latest.j ? \" new\" : \"\") +\n                \" cell_\" +\n                i\n              }\n            >\n              {i ? i : \"\"}{\" \"}\n            </div>\n          </div>\n        );\n      });\n    });\n    return (\n      <>\n        <div>\n          <h1 className=\"welcome\">Welcome on board!</h1>\n          <h3 className=\"score\">Your score: {score ? score : 0}</h3>\n          <h3 className=\"best-score score\">\n            Best score: {bestFromStorage ? bestFromStorage : 0}{\" \"}\n          </h3>\n        </div>\n        <div className=\"field\">\n          {allCells}{\" \"}\n          {isWin ? (\n            <div className=\"loose\">\n              <h1>You win!</h1>\n            </div>\n          ) : (\n            \"\"\n          )}{\" \"}\n          {gameOver ? (\n            <div className=\"loose\">\n              <h1>You loose</h1>\n            </div>\n          ) : (\n            \"\"\n          )}\n        </div>\n      </>\n    );\n  };\n  return initNewField();\n};\nexport default Field;\n","const swipedetect = (el, callback) => {\n\n  let touchsurface = el,\n    swipedir,\n    startX,\n    startY,\n    distX,\n    distY,\n    threshold = 150, //required min distance traveled to be considered swipe\n    restraint = 100, // maximum distance allowed at the same time in perpendicular direction\n    allowedTime = 300, // maximum time allowed to travel that distance\n    elapsedTime,\n    startTime,\n    handleswipe = callback || function(swipedir){}\n\n  touchsurface.addEventListener('touchstart', function(e){\n    let touchobj = e.changedTouches[0]\n    swipedir = 'none'\n    let dist = 0\n    startX = touchobj.pageX\n    startY = touchobj.pageY\n    startTime = new Date().getTime() // record time when finger first makes contact with surface\n    e.preventDefault()\n  }, false)\n\n  touchsurface.addEventListener('touchmove', function(e){\n    e.preventDefault() // prevent scrolling when inside DIV\n  }, false)\n\n  touchsurface.addEventListener('touchend', function(e){\n    let touchobj = e.changedTouches[0]\n    distX = touchobj.pageX - startX // get horizontal dist traveled by finger while in contact with surface\n    distY = touchobj.pageY - startY // get vertical dist traveled by finger while in contact with surface\n    elapsedTime = new Date().getTime() - startTime // get time elapsed\n    if (elapsedTime <= allowedTime){ // first condition for awipe met\n      if (Math.abs(distX) >= threshold && Math.abs(distY) <= restraint){ // 2nd condition for horizontal swipe met\n        swipedir = (distX < 0)? 'left' : 'right' // if dist traveled is negative, it indicates left swipe\n      }\n      else if (Math.abs(distY) >= threshold && Math.abs(distX) <= restraint){ // 2nd condition for vertical swipe met\n        swipedir = (distY < 0)? 'up' : 'down' // if dist traveled is negative, it indicates up swipe\n      }\n    }\n    handleswipe(swipedir)\n    e.preventDefault()\n  }, false)\n}\n\nexport default swipedetect","import React, { Component } from \"react\";\nimport { addToStorage, rotate45, match } from \"../utils/helpers.js\";\nimport Field from \"./field.js\";\nimport swipeDetect from \"../utils/swipeDetection.js\"\nclass App extends Component {\n  state = {\n    cells: [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n    latestCoordinates: {},\n    gameOver: false,\n    score: 0\n  };\n  size = 4;\n\n  componentDidMount() {\n    let { cells } = this.state;\n    let cells1 = this.makeRandomCell(cells);\n    this.setState(this.makeRandomCell(cells1));\n    document.addEventListener(\"keydown\", this.handleKeyDown.bind(this));\n    this.handleSwipe.bind(this);\n  }\n  setBestScore() {\n    let finishScore = this.state.score;\n    let bestFromStorage = JSON.parse(localStorage.getItem(\"score\"));\n    if (finishScore > bestFromStorage) {\n      addToStorage(finishScore, \"score\");\n    }\n  }\n  ifGamesOver(arr) {\n    if (this.isGameOver(arr)) {\n      this.setBestScore();\n      this.setState({ gameOver: true });\n    }\n  }\n  makeRandomCell(data) {\n    let arr = data.slice();\n    let rt = this.availableCells(arr);\n    if (this.availableCells(arr).length) {\n      let randomNumber = Math.floor(Math.random() * rt.length);\n      arr[rt[randomNumber].i][rt[randomNumber].j] = Math.random() < 0.9 ? 2 : 4;\n      this.setState({\n        latestCoordinates: { i: rt[randomNumber].i, j: rt[randomNumber].j }\n      });\n    }\n    return arr;\n  }\n  availableCells(data) {\n    let avCells = [];\n    let cells = data;\n\n    if (cells.length) {\n      for (let i = 0; i < this.size; i++) {\n        for (let j = 0; j < this.size; j++) {\n          if (cells[i][j] === 0) {\n            avCells.push({ i, j });\n          }\n        }\n      }\n    }\n    return avCells;\n  }\n  areMatches(arr) {\n    let cells = arr.slice();\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        return (\n          match(cells, i - 1, j, i, j) ||\n          match(cells, i, j - 1, i, j) ||\n          match(cells, i, j + 1, i, j) ||\n          match(cells, i + 1, j, i, j)\n        );\n      }\n    }\n  }\n  isGameOver(arr) {\n    return (\n      !this.areMatches(this.state.cells) && !this.availableCells(arr).length\n    );\n  }\n  handleKeyDown(event) {\n    const top = 38;\n    const right = 39;\n    const down = 40;\n    const left = 37;\n    let { cells } = this.state;\n\n\n    if (event.keyCode === top) {\n      let newState = this.moveUp(cells);\n      this.setState(newState);\n    } else if (event.keyCode === right) {\n      let newState = this.moveRight(cells);\n      this.setState({ cells: newState });\n    } else if (event.keyCode === down) {\n      let newState = this.moveDown(cells);\n      this.setState({ cells: newState });\n    } else if (event.keyCode === left) {\n      let newState = this.moveLeft(cells);\n      this.setState({ cells: newState });\n    }\n  }\n  handleSwipe =()=>{\n    let field = document.querySelector('.field');\n    let {cells} = this.state;\n\n    swipeDetect(field, function(swipedir){\n      alert('!!!');\n      if (swipedir === 'top') {\n        let newState = this.moveUp(cells);\n        this.setState(newState);\n      } else if (swipedir  === 'right') {\n        let newState = this.moveRight(cells);\n        this.setState({ cells: newState });\n      } else if (swipedir === 'down') {\n        let newState = this.moveDown(cells);\n        this.setState({ cells: newState });\n      } else if (swipedir === 'left') {\n        let newState = this.moveLeft(cells);\n        this.setState({ cells: newState });\n      }\n    })\n  }\n\n\n\n\n\n  checkStep = (arr, i, j, moved) => {\n    if (arr[i][j] !== 0 && arr[i - 1][j] === 0) {\n      arr[i - 1][j] = arr[i][j];\n      arr[i][j] = 0;\n      moved = true;\n      if (i >= 2) {\n        this.checkStep(arr, i - 1, j, moved);\n        moved = true;\n        if (i === 3) {\n          this.checkStep(arr, i - 2, j, moved);\n          moved = true;\n        }\n      }\n    } else if (arr[i][j] === arr[i - 1][j]) {\n      arr[i - 1][j] = arr[i][j] + arr[i - 1][j];\n      let score = this.state.score + arr[i][j];\n      this.setState({ score });\n      arr[i][j] = 0;\n      moved = true;\n    }\n\n    return { arr, moved };\n  };\n  moveUp(data) {\n    let arr = data.slice();\n    let result,\n      moved = false;\n    for (let j = 0; j < this.size; j++) {\n      for (let i = 1; i < this.size; i++) {\n        result = this.checkStep(arr, i, j, moved);\n      }\n    }\n    arr = result.arr;\n    moved = result.moved;\n    this.ifGamesOver(arr);\n    return moved ? this.makeRandomCell(arr) : arr;\n  }\n  moveDown(data) {\n    let arr = data.slice();\n    let arr2 = rotate45(rotate45(arr));\n    let moved = false;\n    let result;\n    for (let j = 0; j < this.size; j++) {\n      for (let i = 1; i < this.size; i++) {\n        result = this.checkStep(arr2, i, j, moved);\n      }\n    }\n    arr = rotate45(rotate45(result.arr));\n    moved = result.moved;\n    this.ifGamesOver(arr);\n    return moved ? this.makeRandomCell(arr) : arr;\n  }\n  moveLeft(data) {\n    let arr = data.slice();\n\n    let rotated = rotate45(arr);\n    let moved = false;\n    let result;\n    for (let j = 0; j < this.size; j++) {\n      for (let i = 1; i < this.size; i++) {\n        result = this.checkStep(rotated, i, j, moved);\n      }\n    }\n    arr = rotate45(rotate45(rotate45(result.arr)));\n    moved = result.moved;\n    this.ifGamesOver(arr);\n    return moved ? this.makeRandomCell(arr) : arr;\n  }\n  moveRight(data) {\n    let arr = data.slice();\n    let rotated = rotate45(rotate45(rotate45(arr)));\n    let moved = false;\n    let result;\n    for (let j = 0; j < this.size; j++) {\n      for (let i = 1; i < this.size; i++) {\n        result = this.checkStep(rotated, i, j, moved);\n      }\n    }\n    arr = rotate45(result.arr);\n    moved = result.moved;\n    this.ifGamesOver(arr);\n    return moved ? this.makeRandomCell(arr) : arr;\n  }\n\n  restart = () => {\n    let cells = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];\n    let allCells = this.makeRandomCell(this.makeRandomCell(cells));\n\n    this.setState({\n      cells: allCells,\n      latestCoordinates: {},\n      gameOver: false,\n      score: 0\n    });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Field props={this.state} />\n        <div className=\"button-wrapper\">\n          <button onClick={this.restart}>New Game</button>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\nserviceWorker.unregister();\n"],"sourceRoot":""}